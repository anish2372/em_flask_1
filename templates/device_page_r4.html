{% extends "base.html" %}
{% block title %}Device - {{ device.device_name or 'Unnamed Device' }}{% endblock %}

{% block content %}
<style>
    body {
        font-family: 'Segoe UI', sans-serif;
        background: #f5f7fa;
        margin: 0;
        padding: 20px;
        color: #333;
    }

    /* The original #top-bar is now empty, but keeping its styles for reference if needed elsewhere */
    #top-bar {
        display: none;
        /* Hide the original top bar as its content is moved */
    }

    .divider {
        opacity: 0.4;
        margin: 0 10px;
    }

    .badge {
        background: #007bff;
        color: #fff;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 14px;
    }

    #card-container {
        display: flex;
        flex-wrap: wrap;
        gap: 25px;
        justify-content: center;
    }

    /* Styles for the device group card */
    .device-group-card {
        background-color: #fff;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        padding: 30px;
        margin-bottom: 25px;
        width: 100%;
        max-width: 1200px;
        box-sizing: border-box;
    }

    .device-group-title {
        font-size: 28px;
        font-weight: bold;
        color: #0056b3;
        margin-bottom: 25px;
        display: flex;
        align-items: center;
        gap: 15px;
        border-bottom: 2px solid #eee;
        padding-bottom: 15px;
    }

    .device-group-title i {
        color: #007bff;
    }

    /* New: Styles for the moved global status bar within the device group card */
    .device-group-status-bar {
        background: #f9f9f9;
        /* Lighter background for distinction */
        padding: 15px 20px;
        margin-bottom: 25px;
        border-radius: 10px;
        /* Slightly less rounded than main card */
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 15px;
        font-weight: 500;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        /* Subtle inner shadow */
    }

    .switch-cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 25px;
        justify-content: center;
    }

    .card {
        background-color: #fff;
        width: 320px;
        border-radius: 15px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.08);
        padding: 20px;
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        box-sizing: border-box;
    }

    .switch-cards-container .card {
        width: calc(33.33% - 17px);
        min-width: 280px;
    }

    .card.expanded {
        width: 100%;
        max-width: 1200px;
    }

    .card-title {
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .card-title i {
        color: #007bff;
    }

    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 15px;
    }

    .status-box {
        background: #f9f9f9;
        border-radius: 10px;
        padding: 12px;
        margin-top: 12px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .status-box h4 {
        margin: 0 0 10px;
        font-size: 16px;
        color: #555;
    }

    .status-box span {
        font-size: 22px;
        font-weight: bold;
        color: #222;
    }

    .toggle-btn {
        background: #007bff;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 15px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 5px;
        white-space: nowrap;
    }

    .toggle-btn:hover {
        opacity: 0.9;
        transform: translateY(-2px);
    }

    .toggle-btn.off {
        background: #dc3545;
    }

    .toggle-btn.on {
        background: #28a745;
    }

    .indicator {
        display: inline-block;
        padding: 8px 14px;
        border-radius: 20px;
        font-weight: bold;
        margin-top: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .fuse-indicator {
        background: #ffc107;
        color: #000;
    }

    .current-indicator {
        background: #e9ecef;
        color: #000;
    }

    .current-indicator.warning {
        background: #ffc107;
        color: #000;
    }

    .current-indicator.fault {
        background: #dc3545;
        color: #fff;
    }

    /* New class for the setting communication indicator to avoid conflicts */
    .current-setting-status-indicator {
        display: inline-block;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #ccc;
        margin-left: 10px;
        vertical-align: middle;
    }

    .current-setting-status-indicator.pending {
        background: #ff9800;
    }

    .current-setting-status-indicator.success {
        background: #4caf50;
    }

    .current-setting-status-indicator.error {
        background: #f44336;
    }


    #toast-container {
        position: fixed;
        top: 20px;
        right: 25px;
        z-index: 1000;
    }

    .toast {
        background: #333;
        color: #fff;
        padding: 12px 18px;
        margin-top: 10px;
        border-radius: 8px;
        animation: fadeout 3s forwards;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    @keyframes fadeout {
        0% {
            opacity: 1;
        }

        80% {
            opacity: 1;
        }

        100% {
            opacity: 0;
            transform: translateY(-10px);
        }
    }

    .flash {
        animation: flash-anim 1s ease;
    }

    @keyframes flash-anim {
        0% {
            background-color: #ffffcc;
        }

        100% {
            background-color: transparent;
        }
    }

    .timer-btn {
        background: #6c757d;
    }

    .timer-btn.on {
        background: #17a2b8;
    }

    .timer-tabs {
        display: flex;
        flex-wrap: wrap;
        border-bottom: 1px solid #ddd;
        margin-bottom: 15px;
    }

    .timer-tab {
        padding: 10px 20px;
        cursor: pointer;
        font-weight: 500;
        border-radius: 6px 6px 0 0;
        background: #f1f1f1;
        margin-right: 5px;
        flex-grow: 1;
        text-align: center;
        white-space: nowrap;
    }

    .timer-tab.active {
        background: #007bff;
        color: white;
    }

    .tab-content {
        display: none;
    }

    .tab-content.active {
        display: block;
    }

    .timer-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
        table-layout: auto;
    }

    .timer-table th,
    .timer-table td {
        padding: 10px 8px;
        border-bottom: 1px solid #eee;
        text-align: center;
    }

    .timer-table th {
        background: #f1f1f1;
        font-weight: 600;
        color: #444;
        text-align: left;
    }

    .timer-table tr:hover {
        background: #f9f9f9;
    }

    .days-container {
        display: flex;
        flex-wrap: wrap;
        gap: 3px;
        justify-content: center;
    }

    .day-btn {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: 1px solid #ddd;
        background: #fff;
        cursor: pointer;
        font-weight: bold;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
    }

    .day-btn.active {
        background: #007bff;
        color: white;
        border-color: #007bff;
    }

    .com-indicator {
        display: inline-block;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #ccc;
        margin: auto;
    }

    .com-indicator.pending {
        background: #ff9800;
    }

    .com-indicator.success {
        background: #4caf50;
    }

    .com-indicator.error {
        background: #f44336;
    }

    .action-btn {
        padding: 5px 10px;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        margin: 0 2px;
        white-space: nowrap;
    }

    .toggle-timer-row-action {
        background: #f1f1f1;
        color: #333;
    }

    .toggle-timer-row-action.on {
        background: #28a745;
        color: white;
    }

    .toggle-timer-row-action.off {
        background: #dc3545;
        color: white;
    }

    .save-timer-action {
        background: #007bff;
        color: white;
    }

    .delete-action {
        background: #f8d7da;
        color: #721c24;
    }

    .add-timer-btn {
        margin-top: 15px;
        padding: 8px 15px;
        background: #28a745;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .timer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
    }

    /* Default state for card-details: hidden */
    .card-details {
        display: none;
        margin-top: 20px;
        border-top: 1px solid #eee;
        padding-top: 20px;
    }

    /* Show card-details only when card is expanded */
    .card.expanded .card-details {
        display: block;
    }

    /* Responsive adjustments */
    @media (max-width: 1024px) {
        .switch-cards-container .card {
            width: calc(50% - 12.5px);
        }
    }

    @media (max-width: 992px) {
        body {
            padding: 10px;
        }
		

        .device-group-status-bar {
            flex-direction: column;
            align-items: flex-start;
            padding: 10px;
            gap: 10px;
        }

        .device-group-status-bar .divider {
            display: none;
        }

        .device-group-status-bar #shutdown-btn {
            margin-left: 0;
            width: 100%;
            justify-content: center;
        }

        .device-group-card {
            padding: 20px;
        }

        .device-group-title {
            font-size: 22px;
            margin-bottom: 15px;
        }
		/* Improve all major buttons */
    .toggle-btn,
    .action-btn,
    .add-timer-btn,
    .timer-tab,
    .day-btn {
        padding: 12px 16px;
        font-size: 25px;
        border-radius: 8px;
    }

    /* Make buttons taller and more touch-friendly */
    <!-- .toggle-btn, -->
    <!-- .action-btn { -->
        <!-- height: 44px; -->
        <!-- font-weight: 600; -->
    <!-- } -->

    .toggle-btn i,
    .action-btn i {
        font-size: 16px;
    }

	.timer-table {
    display: table; /* Use standard table rendering */
    width: 100%; /* Force it to fill the parent card */
    table-layout: fixed; /* Ensure equal column spacing */
    word-break: break-word;
}

.timer-table th,
.timer-table td {
    padding: 12px 6px;
    font-size: 14px;
    text-align: center;
    word-break: break-word;
}
	
	.timer-table td .days-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    gap: 6px;
}

    /* Days button (M T W Th F S Su) improvements */
  
    .days-container {
        justify-content: center;
        gap: 15px;
    }

   

    /* Better spacing for timer tab buttons */
    .timer-tabs {
        gap: 8px;
        padding: 5px 0;
    }

    /* Improve Shutdown button spacing */
    .device-group-status-bar #shutdown-btn {
        margin-top: 10px;
    }

    .timer-header h5 {
        font-size: 26px;
    }

        /* Force single column for switch cards on small screens */
        .switch-cards-container {
            display: flex; /* Keep flex to manage gap */
            flex-direction: column; /* Stack items vertically */
            gap: 15px; /* Maintain the gap between stacked cards */
            flex-wrap: nowrap; /* Prevent wrapping into multiple columns */
        }

        .switch-cards-container .card {
            width: 100%; /* Force each card to take full width */
            min-width: unset; /* Remove any minimum width */
            max-width: 100%; /* Ensure they don't exceed the container width */
        }

        .card.expanded {
            max-width: 100%;
        }

        .card-title {
            font-size: 18px;
        }

        .button-group {
            flex-direction: column;
        }

        .toggle-btn {
            width: 100%;
            justify-content: center;
        }

        .indicator {
            font-size: 14px;
            padding: 6px 10px;
            justify-content: center;
        }

        .status-box h4 {
            font-size: 14px;
        }

        .status-box span {
            font-size: 20px;
        }

        .timer-tabs {
            flex-direction: column;
        }

        .timer-tab {
            margin-right: 0;
            margin-bottom: 5px;
            border-radius: 6px;
        }

        .tab-content {
            overflow-x: auto;
            /* Allow horizontal scrolling for table if needed */
        }

        /*.timer-table {*/
            /*display: block;*/
            /* Make table a block element to enable horizontal scroll */
            /*width: max-content;*/
            /* Allow table to take content width */
            /*min-width: 100%;/*
            /* Ensure it takes at least 100% of parent width */
        /*}*/

        .timer-table th,
        .timer-table td {
            padding: 8px 5px;
            font-size: 12px;
            white-space: normal;
            /* Allow text to wrap in table cells */
            word-break: break-word;
            /* Break long words */
        }

        /* Removed explicit width for Days column to allow dynamic sizing and wrapping */
        .timer-table th:nth-child(2),
        .timer-table td:nth-child(2) {
            /* width: auto; */ /* This is the default, so explicitly removing fixed width */
            /* min-width: unset; */ /* This is the default, so explicitly removing fixed width */
            padding: 8px 2px; /* Adjusted padding for tighter fit */
        }

        .timer-table th:nth-child(1),
        .timer-table th:nth-child(3),
        .timer-table th:nth-child(4),
        .timer-table th:nth-child(5),
        .timer-table th:nth-child(6),
        .timer-table th:nth-child(7) {
            width: auto;
        }

        .days-container {
            flex-wrap: wrap;
            justify-content: flex-start; /* Align day buttons to start */
            gap: 2px; /* Reduce gap further */
        }

        .day-btn {
            width: 20px; /* Even smaller day buttons */
            height: 20px;
            font-size: 8px;
        }

        .time-input {
            width: 60px;
            /* Adjust time input width */
            font-size: 11px;
        }

        .action-btn {
            padding: 3px 6px;
            font-size: 9px;
        }
/* Enhanced timer table UI for mobile */
.timer-table td:first-child {
  font-size: 24px;
  font-weight: 600;
}

/* Day buttons in 4-column grid and bigger */
.days-container {
  display: grid;
  grid-template-columns: repeat(4, 1fr); /* 4 per row */
  gap: 6px;
  justify-items: center;
}

.day-btn {
  width: 48px;
  height: 48px;
  font-size: 14px;
  border-radius: 50%;
}

/* Bigger time inputs */
.time-input {
  width: 100px;
  font-size: 20px;
  padding: 6px 8px;
}

/* Shrink status column to free space */
.com-indicator {
  width: 26px;
  height: 26px;
  margin: auto;
}

.timer-table td:nth-child(5) {
  padding: 0 4px;
  width: 40px;
}

/* Bigger ON/OFF button */
.toggle-timer-row-action {
  font-size: 14px;
  padding: 6px 10px;
  border-radius: 6px;
}

/* Stack Submit/Delete vertically */
.timer-table td:nth-child(7) {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.action-btn {
  font-size: 23px;
  padding: 8px 10px;
  border-radius: 6px;
}


		
    }
</style>

<div id="toast-container"></div>

<template id="device-group-template">
    <div class="device-group-card" data-device-group-id="">
        <div class="device-group-title">
            <i class="fas fa-microchip"></i> Device: {{ device.device_name or 'Unnamed Device' }} (Key: {{ device.device_key }})
        </div>
        <div class="device-group-status-bar">
            <span id="am-status" class="badge">Mode: --</span>
            <span class="divider">|</span>
            <span>Voltage: <strong id="global-voltage">--</strong> V</span>
            <span class="divider">|</span>
            <span>Total Amps: <strong id="global-amps">--</strong> A</span>
            <span class="divider">|</span>
            <span>Frequency: <strong id="global-freq">--</strong> Hz</span>
            <button id="shutdown-btn" class="toggle-btn off" style="margin-left:auto;">
                <i class="fas fa-power-off"></i> Shutdown All
            </button>
        </div>
        <div class="switch-cards-container">
            </div>
    </div>
</template>

<template id="switch-card-template">
    <div class="card" data-device-id="" onclick="expandCard(event, this)">
        <div class="card-title">
            <i class="fas fa-plug"></i> Switch
        </div>
        <div class="button-group">
            <button class="toggle-btn off" onclick="toggleDevice(event)">
                <i class="fas fa-toggle-off"></i> OFF
            </button>
            <button class="toggle-btn timer-btn off" onclick="toggleMasterTimerSwitch(event)">
                <i class="fas fa-clock"></i> Timer OFF
            </button>
        </div>
        <div class="fuse-indicator indicator">
            <i class="fas fa-bolt"></i> Fuse Blown
        </div>
        <div class="current-indicator indicator">
            <i class="fas fa-exclamation-triangle"></i> Current: <span class="current-status">Normal</span>
        </div>
        <div class="status-box">
            <h4><i class="fas fa-bolt"></i> Current (A)</h4>
            <span class="current">0.0</span>
        </div>
        <div class="status-box">
            <h4><i class="fas fa-battery-three-quarters"></i> Energy (KWH)</h4>
            <span class="energy">0.0</span>
        </div>
        <div class="status-box">
            <h4><i class="fas fa-charging-station"></i> Power (W)</h4>
            <span class="power">0.0</span>
        </div>
        <div class="card-details">
            <div class="timer-tabs">
                <div class="timer-tab active" data-tab="voltage">Voltage Settings</div>
                <div class="timer-tab" data-tab="current">Current Settings</div>
                <div class="timer-tab" data-tab="energy">Energy Management</div>
                <div class="timer-tab" data-tab="timer">Timer List</div>
            </div>

            <div id="voltage-tab" class="tab-content active">
                <div class="details-section">
                    <h5>
                        <i class="fas fa-cogs"></i> Voltage Settings
                        <span class="setting-com-indicator voltage-indicator" id="voltage-setting-indicator"></span>
                    </h5>
                    <label>Min Voltage:</label>
                    <input type="number" class="min-voltage" step="1">
                    <label>Max Voltage:</label>
                    <input type="number" class="max-voltage" step="1">
                </div>
            </div>

            <div id="current-tab" class="tab-content">
				<div class="details-section">
				  <h5>
					Current Settings
					<span class="current-setting-status-indicator" id="current-setting-indicator"></span>  </h5>
				  <label>Max Current:</label>
				  <input type="number" class="max-current" step="0.1" onchange="setCurrentLimit(this)">
				</div>
            </div>

            <div id="energy-tab" class="tab-content">
                <div class="details-section">
                    <h5><i class="fas fa-battery-half"></i> Energy Management</h5>
                    <button class="toggle-btn" onclick="resetEnergy(event, this)">
                        <i class="fas fa-redo"></i> Reset Energy
                    </button>
                </div>
            </div>

            <div id="timer-tab" class="tab-content">
                <div class="details-section">
                    <div class="timer-header">
                        <h5><i class="fas fa-list"></i> Timer List</h5>
                        <button class="add-timer-btn" onclick="addTimerEntry(event)"> <i class="fas fa-plus"></i> Add Timer
                        </button>
                    </div>

                    <table class="timer-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Days</th>
                                <th>Start</th>
                                <th>Stop</th>
                                <th>Status</th>
                                <th>Enabled</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody class="timer-body">
                        </tbody>
                    </table>
                </div>
            </div>
            </div>
    </div>
</template>

<div id="card-container"></div>

<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

<script>
    // Define expandCard in the global scope so it's accessible from event listeners
    function expandCard(event, card) {
        const target = event.target;
        // Check if the click originated from an interactive element or its child
        if (target.closest('button') || target.closest('input') || target.classList.contains('timer-tab') || target.classList.contains('day-btn')) {
            return; // Do not expand if an interactive element was clicked
        }
        card.classList.toggle("expanded");
    }

    // Global variables for MQTT client and data
    let client;
    let lastKnownData = {};
    const activeTimerTransactions = {};
    const activeSettingTransactions = {};

    // Global MQTT Topics
    const DEVICE_KEY = "{{ device.device_key }}"; // Get the actual device key from Flask
    const MQTT_REQUEST_TOPIC = `${DEVICE_KEY}/request`;
    const MQTT_RESPONSE_TOPIC = `${DEVICE_KEY}/response`;


    // Function to show toast messages (moved to global scope)
    function showToast(message, isError = false) {
        const toast = document.createElement("div");
        toast.className = "toast";
        toast.textContent = message;
        if (isError) {
            toast.style.backgroundColor = "#dc3545";
        }
        document.getElementById("toast-container").appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    }

    // Function to wait for MQTT to be defined
    function waitForMqtt(callback, retries = 50, delay = 100) {
        if (typeof mqtt !== 'undefined') {
            callback();
        } else if (retries > 0) {
            setTimeout(() => waitForMqtt(callback, retries - 1, delay), delay);
        } else {
            console.error("Failed to load MQTT library after multiple retries. MQTT functionality will be unavailable.");
            showToast("Error: MQTT library failed to load. Please refresh the page.", true);
        }
    }

    // Functions moved to global scope for accessibility
    function publishVoltageSettings(id, minV, maxV) {
        const card = document.querySelector(`.card[data-device-id="${id}"]`);
        // Use the specific ID for the voltage indicator
        const comIndicator = card.querySelector(`#voltage-setting-indicator-${id}`); // Use unique ID
        if (comIndicator) {
            comIndicator.className = "setting-com-indicator pending";
        }
        activeSettingTransactions[`${id}_voltage`] = true;

        const payload = {
            settings: { relay: id, minVoltage: minV, maxVoltage: maxV }
        };
        client.publish(MQTT_REQUEST_TOPIC, JSON.stringify(payload));
        showToast(`Voltage settings sent for Switch ${id + 1}...`);
    }

	function publishCurrentSettings(id, maxC) {
        const card = document.querySelector(`.card[data-device-id="${id}"]`);
        // Target the indicator within the current settings tab using the new class
        const comIndicator = card.querySelector(`#current-setting-indicator-${id}`); // Use unique ID
        if (comIndicator) {
            comIndicator.classList.add("pending"); // Add pending class
            comIndicator.classList.remove("success", "error"); // Ensure other states are removed
        }
        activeSettingTransactions[`${id}_current`] = true;

        const payload = {
            settings: { relay: id, maxCurrent: maxC }
        };
        client.publish(MQTT_REQUEST_TOPIC, JSON.stringify(payload));
        showToast(`Current settings sent for Switch ${id + 1}...`);
    }

    function resetEnergy(event, button) {
        event.stopPropagation();
        const card = button.closest(".card");
        const id = parseInt(card.getAttribute("data-device-id"));
        client.publish(MQTT_REQUEST_TOPIC, JSON.stringify({ resetEnergy: id }));
        showToast(`Energy counter reset for Switch ${id + 1}`);
    }

function createTimerRowElement(deviceId, timerId, initialEnabled = false, initialDays = [0,1,2,3,4,5,6], startTime = "08:00", stopTime = "17:00") {
        const newRow = document.createElement("tr");
        newRow.dataset.timerId = timerId;
        newRow.classList.add("timer-row");

        const dayLabels = ['M', 'T', 'W', 'Th', 'F', 'S', 'Su'];
        let daysHtml = [0, 1, 2, 3, 4, 5, 6].map(dayIndex => {
            const isActive = initialDays.includes(dayIndex);
            return `<button class="day-btn ${isActive ? 'active' : ''}" data-day="${dayIndex}">${dayLabels[dayIndex]}</button>`;
        }).join('');

        newRow.innerHTML = `
            <td>${timerId}</td>
            <td><div class="days-container">${daysHtml}</div></td>
            <td><input type="time" class="time-input start-time" value="${startTime}"></td>
            <td><input type="time" class="time-input stop-time" value="${stopTime}"></td>
            <td><div class="com-indicator"></div></td>
            <td>
                <button class="action-btn toggle-timer-row-action ${initialEnabled ? 'on' : 'off'}">
                    ${initialEnabled ? 'ON' : 'OFF'}
                </button>
            </td>
            <td>
                <button class="action-btn save-timer-action"><i class="fas fa-save"></i> Submit</button>
                <button class="action-btn delete-action"><i class="fas fa-trash"></i> Delete</button>
            </td>
        `;

        const dayButtons = newRow.querySelectorAll(".day-btn");
        dayButtons.forEach(btn => {
            btn.onclick = (e) => {
                e.stopPropagation();
                btn.classList.toggle("active");
            };
        });

        newRow.querySelector(".toggle-timer-row-action").onclick = (e) => toggleTimerEntryEnabled(e);
		newRow.querySelector(".save-timer-action").onclick = (e) => saveTimerConfig(e);
        newRow.querySelector(".delete-action").onclick = (e) => deleteTimerEntry(e);

        return newRow;
    }

    function addTimerEntry(event) {
        event.stopPropagation();
        const card = event.target.closest(".card");
        const deviceId = parseInt(card.getAttribute("data-device-id"));
        const tbody = card.querySelector(".timer-body");

        const existingTimers = tbody.querySelectorAll("tr").length;
        // Generate a more robust unique ID, e.g., based on timestamp or UUID if available
        const newTimerId = `T${Date.now().toString().slice(-4)}${existingTimers + 1}`; // Simple unique ID
        const newRow = createTimerRowElement(deviceId, newTimerId);

        tbody.appendChild(newRow);
        showToast(`New timer row ${newTimerId} added for Switch ${deviceId + 1}. Configure and save.`);
    }

    function saveTimerConfig(event) {
        event.stopPropagation();
        const buttonOrInput = event.target;
        const row = buttonOrInput.closest("tr");
        const card = row.closest(".card");
        const deviceId = parseInt(card.getAttribute("data-device-id"));
        const timerId = row.dataset.timerId;

        const startTime = row.querySelector(".start-time").value;
        const stopTime = row.querySelector(".stop-time").value;
        // Ensure selectedDays are parsed as integers
        const selectedDays = Array.from(row.querySelectorAll(".days-container .day-btn.active")).map(btn => parseInt(btn.dataset.day));
        const isEnabled = row.querySelector(".toggle-timer-row-action").classList.contains("on");

        const payload = {
            action: "save_timer",
            deviceId: deviceId,
            timerId: timerId,
            days: selectedDays,
            startTime: startTime,
            stopTime: stopTime,
            enabled: isEnabled
        };

        client.publish(MQTT_REQUEST_TOPIC, JSON.stringify(payload));
        row.querySelector(".com-indicator").className = "com-indicator pending";
        activeTimerTransactions[`${deviceId}_${timerId}`] = 'save';
        showToast(`Saving Timer ${timerId} for Switch ${deviceId + 1}...`);
    }

    function deleteTimerEntry(event) {
        event.stopPropagation();
        const button = event.target.closest(".delete-action");
        const row = button.closest("tr");
        const card = row.closest(".card");
        const deviceId = parseInt(card.getAttribute("data-device-id"));
        const timerId = row.dataset.timerId;

        // Use a custom modal or a more robust confirmation if alert() is not allowed (as per instructions)
        // For now, keeping confirm() as it was in the original code, but note the instruction.
        if (confirm(`Are you sure you want to delete Timer ${timerId} for Switch ${deviceId + 1}?`)) {
            const payload = {
                action: "delete_timer",
                deviceId: deviceId,
                timerId: timerId
            };
            client.publish(MQTT_REQUEST_TOPIC, JSON.stringify(payload));
            row.querySelector(".com-indicator").className = "com-indicator pending";
            activeTimerTransactions[`${deviceId}_${timerId}`] = 'delete';
            showToast(`Deleting Timer ${timerId} for Switch ${deviceId + 1}...`);
        }
    }

    function toggleTimerEntryEnabled(event) {
        event.stopPropagation();
        const button = event.target.closest(".toggle-timer-row-action");
        const row = button.closest("tr");
        const card = row.closest(".card");
        const deviceId = parseInt(card.getAttribute("data-device-id"));
        const timerId = row.dataset.timerId;

        const currentIsEnabled = button.classList.contains("on");
        const newIsEnabled = !currentIsEnabled;

        const payload = {
            action: "toggle_timer_entry",
            deviceId: deviceId,
            timerId: timerId,
            enabled: newIsEnabled
        };
        client.publish(MQTT_REQUEST_TOPIC, JSON.stringify(payload));
        row.querySelector(".com-indicator").className = "com-indicator pending";
        activeTimerTransactions[`${deviceId}_${timerId}`] = 'toggle';
        showToast(`Toggling Timer ${timerId} for Switch ${deviceId + 1} to ${newIsEnabled ? "ON" : "OFF"}`);
    }

    function updateTimerRowFromData(row, timerData) {
        // Ensure timerId is updated if it changed (e.g., from temporary to permanent)
        row.dataset.timerId = timerData.timerId;
        row.cells[0].textContent = timerData.timerId;

        const daysContainer = row.querySelector(".days-container");
        daysContainer.querySelectorAll(".day-btn").forEach((btn) => {
            const day = parseInt(btn.dataset.day); // Ensure comparison with integer
            btn.classList.toggle("active", timerData.days.includes(day));
        });

        row.querySelector(".start-time").value = timerData.startTime;
        row.querySelector(".stop-time").value = timerData.stopTime;

        const toggleBtn = row.querySelector(".toggle-timer-row-action");
        toggleBtn.textContent = timerData.enabled ? "ON" : "OFF";
        toggleBtn.classList.toggle("on", timerData.enabled);
        toggleBtn.classList.toggle("off", !timerData.enabled);

        row.querySelector(".com-indicator").className = "com-indicator success";
    }


    // Wrap the rest of the script in DOMContentLoaded to ensure all HTML and external scripts are loaded
	const MAC_ADDRESS = "{{ device.device_key }}";
    document.addEventListener("DOMContentLoaded", function() {
        const NUM_DEVICES = 8; // Number of switches per physical device
		//const MAC_ADDRESS = "{{ device.device_key }}";
        // DEVICE_KEY, MQTT_REQUEST_TOPIC, MQTT_RESPONSE_TOPIC are now global

        const container = document.getElementById("card-container");
        const deviceGroupTemplate = document.getElementById("device-group-template");
        const switchCardTemplate = document.getElementById("switch-card-template");

        // lastKnownData will be initialized with data from Flask
       
        const rawLastStateString = '{{ last_state | tojson | safe | default("{}") }}'.trim();
        let initialLastKnownData = {};

        if (rawLastStateString.startsWith('{{') && rawLastStateString.endsWith('}}')) {
            initialLastKnownData = {}; // Default to empty object if templating failed
        } else if (rawLastStateString && rawLastStateString !== 'null') { // Only attempt to parse if the string is not empty or 'null'
            try {
                initialLastKnownData = JSON.parse(rawLastStateString);
            } catch (e) {
                console.error("Error parsing last_state JSON:", e);
                console.error("Raw string that caused error:", rawLastStateString);
                // initialLastKnownData remains {} if parsing fails
            }
        }
        Object.assign(lastKnownData, initialLastKnownData); // Assign to global lastKnownData


        // Start waiting for MQTT library to load
        waitForMqtt(() => {
            client = mqtt.connect("wss://mqtt.eclipseprojects.io:443/mqtt");

            client.on("connect", () => {
                console.log("MQTT Connected!");
                client.subscribe(MQTT_RESPONSE_TOPIC);
                console.log(`Subscribed to ${MQTT_RESPONSE_TOPIC}`);

                // Request full state from the device when connected
                client.publish(MQTT_REQUEST_TOPIC, JSON.stringify({ request_full_state: 1 }));
                console.log(`Published request_full_state to ${MQTT_REQUEST_TOPIC}`);
            });

            client.on("reconnect", () => {
                console.log("MQTT Reconnecting...");
            });

            client.on("error", (err) => {
                console.error("MQTT Error:", err);
                showToast(`MQTT Connection Error: ${err.message}`, true);
            });

            // This is the primary MQTT message handler
            client.on("message", (topic, message) => {
                try {
                    const incoming = JSON.parse(message.toString());
                    console.log("MQTT Message received:", incoming);

                    if (topic === MQTT_RESPONSE_TOPIC) {
                        if (incoming.settings_response) {
                            handleSettingsActionResponse(incoming.settings_response);
                        } else if (incoming.timer_response) {
                            handleTimerActionResponse(incoming.timer_response);
                        } else if (incoming.relay_response) { // <--- NEW: Handle relay state responses
                            const { deviceId, state, status, message } = incoming.relay_response;
                            const card = document.querySelector(`.card[data-device-id="${deviceId}"]`);
                            if (card) {
                                const powerBtn = card.querySelector(".toggle-btn:not(.timer-btn)");
                                if (status === "success") {
                                    const newStateText = state === 1 ? "ON" : "OFF";
                                    powerBtn.textContent = newStateText;
                                    powerBtn.classList.toggle("off", state === 0);
                                    powerBtn.classList.toggle("on", state === 1);
                                    showToast(`Switch ${deviceId + 1} is now ${newStateText}.`);
                                } else if (status === "error") {
                                    showToast(`Error: Switch ${deviceId + 1} failed to update: ${message}`, true);
                                }
                            }
                        } else if (incoming.shutdown_response) { // <--- NEW: Handle shutdown responses
                            const { status, message } = incoming.shutdown_response;
                            if (status === "success") {
                                showToast(message);
                                // Optionally, iterate through all relays and set their state to OFF in UI
                                for (let i = 0; i < NUM_DEVICES; i++) {
                                    const card = document.querySelector(`.card[data-device-id="${i}"]`);
                                    if (card) {
                                        const powerBtn = card.querySelector(".toggle-btn:not(.timer-btn)");
                                        powerBtn.textContent = "OFF";
                                        powerBtn.classList.remove("on");
                                        powerBtn.classList.add("off");
                                    }
                                }
                            } else {
                                showToast(`Shutdown failed: ${message}`, true);
                            }
                        } else if (incoming.master_timer_response) { // <--- NEW: Handle master timer responses
                            const { deviceId, state, status, message } = incoming.master_timer_response;
                            const card = document.querySelector(`.card[data-device-id="${deviceId}"]`);
                            if (card) {
                                const timerBtn = card.querySelector(".timer-btn");
                                if (status === "success") {
                                    const newStateText = state === 1 ? "ON" : "OFF";
                                    timerBtn.innerHTML = `<i class="fas fa-clock"></i> Timer ${newStateText}`;
                                    timerBtn.classList.toggle("on", state === 1);
                                    timerBtn.classList.toggle("off", state === 0);
                                    showToast(`Master Timer for Switch ${deviceId + 1} is now ${newStateText}.`);
                                } else if (status === "error") {
                                    showToast(`Error: Master Timer for Switch ${deviceId + 1} failed: ${message}`, true);
                                }
                            }
                        } else if (incoming.energy_reset_response) { // <--- NEW: Handle energy reset responses
                            const { deviceId, status, message } = incoming.energy_reset_response;
                            const card = document.querySelector(`.card[data-device-id="${deviceId}"]`);
                            if (card && status === "success") {
                                // Update the energy display to 0.0
                                updateTextWithFlash(card.querySelector(".energy"), "0.00");
                                showToast(message);
                            } else if (card && status === "error") {
                                showToast(`Error: Energy reset for Switch ${deviceId + 1} failed: ${message}`, true);
                            }
                        }
                        else {
                            // This is assumed to be a full state update or periodic data
                            Object.assign(lastKnownData, incoming); // Update lastKnownData with incoming MQTT data
                            console.log("Full state update received:", lastKnownData);

                            const autoMode = lastKnownData[91] === 1; // Assuming register 91 for auto/manual mode
                            const deviceGroupCard = document.querySelector(".device-group-card");
                            if (deviceGroupCard) {
                                updateTextWithFlash(deviceGroupCard.querySelector("#global-voltage"), (lastKnownData[40] || 0).toFixed(1)); // Register 40 for voltage
                                let totalAmps = 0;
                                for (let i = 0; i < NUM_DEVICES; i++) {
                                    totalAmps += parseFloat(lastKnownData[32 + i] || 0); // Registers 32-39 for amps
                                }
                                updateTextWithFlash(deviceGroupCard.querySelector("#global-amps"), totalAmps.toFixed(2));
                                updateTextWithFlash(deviceGroupCard.querySelector("#global-freq"), (lastKnownData[42] || 0).toFixed(1)); // Register 42 for frequency

                                const modeEl = deviceGroupCard.querySelector("#am-status");
                                const modeText = autoMode ? "AUTO" : "MANUAL";
                                modeEl.textContent = "Mode: " + modeText;
                                modeEl.style.background = autoMode ? "#28a745" : "#dc3545";
                            }


                            for (let i = 0; i < NUM_DEVICES; i++) {
                                const card = document.querySelector(`.card[data-device-id="${i}"]`);
                                if (!card) continue;

                                const relayState = lastKnownData[8 + i] ? "ON" : "OFF"; // Registers 8-15 for relay state
                                const fuseStatus = lastKnownData[16 + i] ? "Blown" : "OK"; // Registers 16-23 for fuse status
                                const current = lastKnownData[32 + i] || 0; // Registers 32-39 for current
                                const energy = lastKnownData[51 + i] || 0; // Registers 51-58 for energy
                                const voltage = lastKnownData[40] || 0; // Global voltage
                                const currentStatus = lastKnownData[67 + i] || 0; // Registers 67-74 for current status
                                const masterTimerEnabled = lastKnownData[93 + i] === 1; // Registers 93-100 for master timer switch

                                const powerBtn = card.querySelector(".toggle-btn:not(.timer-btn)");
                                powerBtn.textContent = relayState;
                                powerBtn.classList.toggle("off", relayState === "OFF");
                                powerBtn.classList.toggle("on", relayState === "ON");
                                // Power button disabled if master timer is ON or if not in auto mode
                                powerBtn.disabled = masterTimerEnabled || !autoMode;

                                const timerBtn = card.querySelector(".timer-btn");
                                timerBtn.innerHTML = `<i class="fas fa-clock"></i> Timer ${masterTimerEnabled ? "ON" : "OFF"}`;
                                timerBtn.classList.toggle("on", masterTimerEnabled);
                                timerBtn.classList.toggle("off", !masterTimerEnabled);
                                // Master timer button disabled if not in auto mode
                                timerBtn.disabled = !autoMode;

                                const currentIndicator = card.querySelector(".current-indicator");
                                const currentStatusText = ["Normal", "Low/High Current", "Over Current Trip"][currentStatus] || "Unknown";
                                currentIndicator.querySelector(".current-status").textContent = currentStatusText;
                                // Use classList.remove and add to avoid overwriting existing classes
                                currentIndicator.classList.remove("warning", "fault"); // Remove previous status classes
                                if (currentStatus === 1) currentIndicator.classList.add("warning");
                                else if (currentStatus === 2) currentIndicator.classList.add("fault");

                                const power = voltage * current;
                                updateTextWithFlash(card.querySelector(".current"), current.toFixed(2));
                                updateTextWithFlash(card.querySelector(".energy"), energy.toFixed(2));
                                updateTextWithFlash(card.querySelector(".power"), power.toFixed(2));

                                const fuseEl = card.querySelector(".fuse-indicator");
                                fuseEl.innerHTML = `<i class='fas fa-bolt'></i> Fuse ${fuseStatus}`;
                                fuseEl.style.backgroundColor = fuseStatus === "Blown" ? "#dc3545" : "#ffc107";
                                fuseEl.style.color = fuseStatus === "Blown" ? "#fff" : "#000";

                                // Disable settings inputs if not in auto mode
                                card.querySelector(".min-voltage").disabled = !autoMode;
                                card.querySelector(".max-voltage").disabled = !autoMode;
                                card.querySelector(".max-current").disabled = !autoMode;

                                // Update input values with last known data
                                card.querySelector(".min-voltage").value = lastKnownData[43 + i] !== undefined ? lastKnownData[43 + i] : ''; // Registers 43-50 for min voltage
                                card.querySelector(".max-voltage").value = lastKnownData[44 + i] !== undefined ? lastKnownData[44 + i] : ''; // Registers 44-50 for max voltage
                                card.querySelector(".max-current").value = lastKnownData[24 + i] !== undefined ? lastKnownData[24 + i] : ''; // Registers 24-31 for max current

                                // Populate timers for the device
                                // The firmware sends timers one by one, with "0" as the device ID.
                                // This UI logic expects `device_timers[i]` to be an array of timers for device `i`.
                                // If the firmware sends `{"device_timers": {"0": [...]}}`, this will work for device 0.
                                // If you have timers for multiple devices, the firmware needs to send them with their respective device IDs.
                                if (incoming.device_timers && incoming.device_timers[i]) {
                                    populateTimersForDevice(card, i, incoming.device_timers[i]);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error("MQTT JSON error or data parsing error:", e);
                    showToast("Error processing MQTT data. Check console.", true);
                }
            });
        }); // End of waitForMqtt callback


        function handleTimerActionResponse(response) {
            const { deviceId, timerId, action_ack, status, message, timerData } = response;
            const card = document.querySelector(`.card[data-device-id="${deviceId}"]`);
            if (!card) {
                console.warn(`handleTimerActionResponse: Card not found for deviceId ${deviceId}`);
                return;
            }

            const tbody = card.querySelector(".timer-body");
            let targetRow = null;
            tbody.querySelectorAll("tr").forEach(row => {
                if (row.dataset.timerId === timerId) {
                    targetRow = row;
                }
            });

            if (!targetRow) {
                console.warn(`handleTimerActionResponse: Timer row not found for response: device ${deviceId}, timer ${timerId}`);
                // If a new timer was just saved and assigned a new ID by firmware, we might need to add it
                if (action_ack === "save_timer_ack" && timerData) {
                    console.log("Attempting to add new timer row based on firmware response.");
                    const newRow = createTimerRowElement(
                        deviceId, 
                        timerData.timerId,
                        timerData.enabled,
                        timerData.days,
                        timerData.startTime,
                        timerData.stopTime
                    );
                    tbody.appendChild(newRow);
                    targetRow = newRow; // Set targetRow to the newly created row
                } else {
                    return; // Cannot proceed without a target row
                }
            }

            const comIndicator = targetRow.querySelector(".com-indicator");
            const transactionKey = `${deviceId}_${timerId}`;

            if (comIndicator) { // Ensure indicator exists
                comIndicator.classList.remove("pending", "success", "error"); // Clear previous states
                if (status === "success") {
                    comIndicator.classList.add("success");
                    showToast(message || `Timer ${timerId} on Switch ${deviceId + 1}: Action successful.`);

                    if (action_ack === "delete_timer_ack") {
                        targetRow.remove();
                        // Re-index displayed timer IDs if they are sequential
                        const remainingRows = tbody.querySelectorAll("tr");
                        remainingRows.forEach((row, index) => {
                            // Only re-index if not a custom ID (e.g., T_custom_...)
                            if (!row.dataset.timerId.startsWith("T")) { // Assuming T prefix for new timers
                                const newTId = `T${index + 1}`;
                                row.cells[0].textContent = newTId;
                                row.dataset.timerId = newTId;
                            }
                        });
                    } else if (action_ack === "save_timer_ack" && timerData) {
                        updateTimerRowFromData(targetRow, timerData);
                    } else if (action_ack === "toggle_timer_entry_ack" && timerData) {
                        const toggleBtn = targetRow.querySelector(".toggle-timer-row-action");
                        toggleBtn.textContent = timerData.enabled ? "ON" : "OFF";
                        toggleBtn.classList.toggle("on", timerData.enabled);
                        toggleBtn.classList.toggle("off", !timerData.enabled);
                    }

                } else if (status === "error") {
                    comIndicator.classList.add("error");
                    showToast(`Timer Error (Switch ${deviceId + 1}, ${timerId}): ${message || 'Unknown error'}`, true);
                }
            }
            delete activeTimerTransactions[transactionKey];
        }

        function handleSettingsActionResponse(response) {
            const { deviceId, settingType, status, message } = response;
            const card = document.querySelector(`.card[data-device-id="${deviceId}"]`);
            if (!card) {
                console.warn(`handleSettingsActionResponse: Card not found for deviceId ${deviceId}`);
                return;
            }

            // Select the correct indicator based on settingType
            let comIndicator;
            if (settingType === "voltage") {
                comIndicator = card.querySelector(`#voltage-setting-indicator-${deviceId}`);
            } else if (settingType === "current") {
                comIndicator = card.querySelector(`#current-setting-indicator-${deviceId}`);
            }
            // Add more conditions for other setting types if they are introduced

            if (!comIndicator) {
                console.warn(`Setting indicator not found for response: device ${deviceId}, type ${settingType}`);
                return;
            }

            const transactionKey = `${deviceId}_${settingType}`;

            // Update classes using classList methods for better control
            comIndicator.classList.remove("pending", "success", "error"); // Clear previous states
            if (status === "success") {
                comIndicator.classList.add("success");
                showToast(message || `${settingType} settings for Switch ${deviceId + 1}: Action successful.`);
            } else if (status === "error") {
                comIndicator.classList.add("error");
                showToast(`${settingType} Settings Error (Switch ${deviceId + 1}): ${message || 'Unknown error'}`, true);
            }
            // If status is neither success nor error, it remains without specific status classes (e.g., default grey)

            delete activeSettingTransactions[transactionKey];
        }


		    // CORRECTED FUNCTION CALL
     function populateTimersForDevice(card, deviceId, timersDataArray) {
        const tbody = card.querySelector(".timer-body");
        tbody.innerHTML = ""; // Clear existing timers

        if (timersDataArray && timersDataArray.length > 0) {
            timersDataArray.forEach(timerData => {
                const newRow = createTimerRowElement(
                    deviceId, 
                    timerData.timerId,
                    timerData.enabled,
                    timerData.days,
                    timerData.startTime,
                    timerData.stopTime
                );
                tbody.appendChild(newRow);
            });
        }
    }

    function toggleDevice(event) {
        event.stopPropagation();
        const card = event.target.closest(".card");
        const deviceId = parseInt(card.getAttribute("data-device-id"));
        const powerBtn = event.target.closest(".toggle-btn:not(.timer-btn)");

        // Determine the new state based on current state
        const isCurrentlyOff = powerBtn.classList.contains("off");
        const newState = isCurrentlyOff ? 1 : 0; // 1 for ON, 0 for OFF

        client.publish(MQTT_REQUEST_TOPIC, JSON.stringify({
            relay: deviceId,
            state: newState
        }));
        showToast(`Command sent to Switch ${deviceId + 1} to turn ${newState ? "ON" : "OFF"}`);
        // Optimistic UI update - will be corrected by firmware response if needed
        powerBtn.textContent = newState ? "ON" : "OFF";
        powerBtn.classList.toggle("off", newState === 0);
        powerBtn.classList.toggle("on", newState === 1);
    }

    function toggleMasterTimerSwitch(event) {
        event.stopPropagation();
        const button = event.target.closest(".timer-btn");
        const card = button.closest(".card");
        const deviceId = parseInt(card.getAttribute("data-device-id"));
        const autoMode = lastKnownData[91] === 1; // Assuming register 91 indicates auto/manual mode

        if (!autoMode) {
            showToast("Timers can only be managed in AUTO mode.", true);
            return;
        }

        const currentTimerState = button.classList.contains("on");
        const newTimerState = !currentTimerState; // Toggle state

        client.publish(MQTT_REQUEST_TOPIC, JSON.stringify({
            relay: deviceId, // Send relay ID for master timer switch
            timer_master_switch: newTimerState ? 1 : 0
        }));
        showToast(`Master Timer for Switch ${deviceId + 1} command sent to turn ${newTimerState ? "ON" : "OFF"}`);
        // Optimistic UI update
        button.innerHTML = `<i class="fas fa-clock"></i> Timer ${newTimerState ? "ON" : "OFF"}`;
        button.classList.toggle("on", newTimerState);
        button.classList.toggle("off", !newTimerState);
    }


    function updateTextWithFlash(el, newText) {
        if (el && el.textContent !== newText) {
            el.textContent = newText;
            el.classList.add("flash");
            setTimeout(() => el.classList.remove("flash"), 1000);
        }
    }

    // Initial card rendering logic (moved inside DOMContentLoaded)
    const deviceGroupClone = deviceGroupTemplate.content.cloneNode(true);
    const deviceGroupCard = deviceGroupClone.querySelector(".device-group-card");
    const switchCardsContainer = deviceGroupCard.querySelector(".switch-cards-container");

    // Attach event listener for the Shutdown All button now that it's part of the deviceGroupCard
    const shutdownBtn = deviceGroupCard.querySelector("#shutdown-btn");
    if (shutdownBtn) {
        shutdownBtn.onclick = () => {
            client.publish(MQTT_REQUEST_TOPIC, JSON.stringify({ shutdown: 1 }));
            showToast("Shutdown command sent to all switches");
        };
    }

    for (let i = 0; i < NUM_DEVICES; i++) {
        const clone = switchCardTemplate.content.cloneNode(true);
        const card = clone.querySelector(".card");
        card.setAttribute("data-device-id", i);
        card.querySelector(".card-title").innerHTML = `<i class="fas fa-plug"></i> Switch ${i + 1}`;

        // Assign unique IDs to voltage and current setting indicators
        const voltageIndicator = card.querySelector('#voltage-setting-indicator');
        if (voltageIndicator) {
            voltageIndicator.id = `voltage-setting-indicator-${i}`; // Make ID unique per card
        }
        const currentSettingIndicator = card.querySelector('#current-setting-indicator');
        if (currentSettingIndicator) {
            currentSettingIndicator.id = `current-setting-indicator-${i}`; // Make ID unique per card
        }

        const mainToggleButton = card.querySelector(".toggle-btn:not(.timer-btn)");
        mainToggleButton.onclick = (e) => toggleDevice(e); // Call toggleDevice directly

        const masterTimerButton = card.querySelector(".timer-btn");
        masterTimerButton.onclick = (e) => toggleMasterTimerSwitch(e);

        const submitVoltageBtn = document.createElement("button");
        submitVoltageBtn.textContent = "Submit Voltage Settings";
        submitVoltageBtn.className = "toggle-btn";
        submitVoltageBtn.style.marginTop = "15px";
        submitVoltageBtn.style.backgroundColor = "#007bff";
        submitVoltageBtn.onclick = (e) => {
            e.stopPropagation();
            const id = parseInt(card.getAttribute("data-device-id"));
            const minV = parseFloat(card.querySelector(".min-voltage").value);
            const maxV = parseFloat(card.querySelector(".max-voltage").value);
            publishVoltageSettings(id, minV, maxV);
        };
        card.querySelector("#voltage-tab .details-section").appendChild(submitVoltageBtn);

        const submitCurrentBtn = document.createElement("button");
        submitCurrentBtn.textContent = "Submit Current Settings";
        submitCurrentBtn.className = "toggle-btn";
        submitCurrentBtn.style.marginTop = "15px";
        submitCurrentBtn.style.backgroundColor = "#007bff";
        submitCurrentBtn.onclick = (e) => {
            e.stopPropagation();
            const id = parseInt(card.getAttribute("data-device-id"));
            const maxC = parseFloat(card.querySelector(".max-current").value);
            publishCurrentSettings(id, maxC);
        };
        card.querySelector("#current-tab .details-section").appendChild(submitCurrentBtn);

        switchCardsContainer.appendChild(clone);
    }

    container.appendChild(deviceGroupClone);

    // Tab switching functionality (delegated to document)
    document.addEventListener("click", function(e) {
      if (e.target.classList.contains("timer-tab")) {
        const tab = e.target;
        const card = tab.closest(".card");
        const tabs = card.querySelectorAll(".timer-tab");
        const contents = card.querySelectorAll(".tab-content");
        
        tabs.forEach(t => t.classList.remove("active"));
        contents.forEach(c => c.classList.remove("active"));
        
        tab.classList.add("active");
        const contentId = tab.getAttribute("data-tab") + "-tab";
        const activeContent = card.querySelector(`#${contentId}`);
        if (activeContent) activeContent.classList.add("active");
      }
    });

}); // End of DOMContentLoaded

// Function to set current limit, now calling the consistent publishCurrentSettings
window.setCurrentLimit = function(input) {
    const card = input.closest(".card");
    const id = parseInt(card.dataset.deviceId);
    const value = parseFloat(input.value);
    
    // Call the existing publishCurrentSettings function for consistency
    publishCurrentSettings(id, value);
};

</script>
{% endblock %}
